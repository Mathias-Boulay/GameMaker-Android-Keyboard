<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize many things;
Interact = false;
Console_width = display_get_gui_width()-2;
Console_height = max(display_get_gui_height()/2,min(240,display_get_gui_height()));
display_set_gui_maximise();

x_mouse = device_mouse_x_to_gui(0);
y_mouse = device_mouse_y_to_gui(0);

Body_color = c_black;           //make_colour_rgb(30,30,30) Dark grey;
Body_color_light = c_black;      //make_color_rgb(50,50,50); Light grey;

draw_colour = "";
draw_alpha = "";
draw_shader = "";

Overlay_drawing = true;
Force_debug_instances_visible = false;
Force_all_instances_visible = false;
Auto_destroy_instance_follower = true;

Tracked_instances[0] = "";

//Command interface part:
Typed_text = "";
Displayed_text = __spse_text_converter_to_sprite_index(Typed_text);

history_index = -1
for(i=0;i&lt;10;i+=1){
    Commands_history[i] = "";
    }

for(i=0;i&lt;10;i++){
    Logs[i,0]= "";
    Logs[i,1]= "";
    ConvertedLogs[i] = __spse_text_converter_to_sprite_index(Logs[i,0]);
    }
    
Available_keys = '!"#$%&amp;'+"'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ";
blink = true;
blink_speed = (room_speed/2);
alarm[11] = blink_speed;
blink_position = 1;

//Initialize a big ds_map:
global.Keys = ds_map_create();

for(i=1;i&lt;=string_length(Available_keys);i++){
    global.Keys[? string_char_at(Available_keys,i)] = (i-1);
    }
    







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Switch the blink status
blink = !blink;
alarm[11] = blink_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update the gui size, check if there are dead instances and get the mouse positions:
Console_width = display_get_gui_width()-2;
Console_height = min(floor(display_get_gui_height()/2),min(240,display_get_gui_height()));
//display_set_gui_maximise();

//update mouse position
x_mouse = device_mouse_x_to_gui(0);
y_mouse = device_mouse_y_to_gui(0);

//Check dead instances.
for(i=0;i&lt;array_length_1d(Tracked_instances);i+=1){
    //First step: Flush instances that don't exist anymore:
    if !instance_exists(Tracked_instances[i]){
        Tracked_instances[i] = "";
        }
    }
    
//Second step: Remove empty intermediate spaces:
for(i=1;i&lt;array_height_2d(Tracked_instances)-1;i++){
    for(j=0;j&gt;-1;j++){
        if (Tracked_instances[i-j] != "") &amp;&amp; (Variables[i-1-j] = ""){
            //Transfer the variable name 
            Tracked_instances[i-j-1] = Tracked_instances[i-j];
            //Flush the old place.
            Variables[i-j] = "";
            }
        else{
            
            i+=j; //Jump through the void created by the for loop.
            break;
            }
        }
    
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="55">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Track the first object found.
var mouse_collision;
mouse_collision = collision_point(mouse_x,mouse_y,all,true,true);
if (mouse_collision != noone){
    //We keep note of the tracked instance:
    for(i=0;i&lt;array_length_1d(Tracked_instances);i++){
        if Tracked_instances[i] = ""{
            //Then we have something to put into.
            Tracked_instances[i] = mouse_collision;
            //On va traquer cette instance:
            var This_object = instance_create(0,0,object_instance_follower);
            This_object.Instance_to_track = mouse_collision;  //This is the instance specific ID
            This_object.Instance_name = __spse_text_converter_to_sprite_index(object_get_name(mouse_collision.object_index)+"!");
            This_object.Instance_string_name = object_get_name(mouse_collision.object_index);
            break;
            }
        else{
            if mouse_collision = Tracked_instances[i]{ //We found the same instance already being tracked !
                break;
                }
            }
        
        }
    //If we found no room within the existing array, let's make more room !
    if i = array_length_1d(Tracked_instances){
        Tracked_instances[i] = mouse_collision;
        //On va traquer cette instance:
        var This_object = instance_create(0,0,object_instance_follower);    
        This_object.Instance_to_track = mouse_collision;  //This is the instance specific ID
        This_object.Instance_name = __spse_text_converter_to_sprite_index(object_get_name(mouse_collision.object_index)+"!");
        This_object.Instance_string_name = object_get_name(mouse_collision.object_index);
        }
    

    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the main window GUI if the user wants so.
if(Interact){   //It means we have to draw the gui
    //Backup drawing settings to restore them.
    draw_color = draw_get_colour();
    draw_alpha = draw_get_alpha();
    draw_shader = shader_current();
   
    //Set drawing conditions:
    shader_reset();
    draw_set_alpha(0.8);
    draw_set_colour(Body_color);
    
    //Background:
    draw_roundrect_ext(0,0,Console_width,Console_height,5,5,false);
    
    draw_set_alpha(1);
    //Time to draw the logs !
    var tmp_counter = 0;
    var tmp_position = Console_height-8;
    repeat(min(floor((Console_height-8)/16),array_height_2d(Logs))){
        __spse_draw_text_sprite_font_colored(16,tmp_position,ConvertedLogs[tmp_counter],Logs[tmp_counter,1]);
        tmp_position-=16;
        tmp_counter+=1;                                 
        }
      
     
    draw_set_color(c_white);
    //Draw the command text section.
    __spse_draw_text_sprite_font(32,16, Displayed_text);
    if (blink){
        draw_line(((blink_position-1)*8)+28,11,((blink_position-1)*8)+28,19);
        }

    
                        
    
    
    
    //Reset to the usual state:
    draw_set_color(draw_color);
    shader_set(draw_shader);
    draw_set_alpha(draw_alpha);
    
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="115">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Switch the visibility state of the debugger:
Interact = !Interact;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update the string displayed on the screen
if Interact{
    blink = true;
    alarm[11] = blink_speed;
    
    if (string_count(keyboard_lastchar, Available_keys) and string_length(keyboard_lastchar) == 1){
        
        switch(keyboard_lastchar){
                
            default:
                __spse_reset_history_index();
                Typed_text = string_insert(keyboard_lastchar,Typed_text,blink_position);
                blink_position+=1;
                break;
            }
               
        }
        
        
    if !keyboard_check(vk_control){
        if !keyboard_check(vk_shift){
        
            switch(keyboard_key){
                case vk_backspace:
                    __spse_reset_history_index();
                    Typed_text = string_delete(Typed_text,blink_position-1,1);
                    blink_position = max(blink_position-1,1);
                    break;
                    
                case vk_up:
                    history_index = min(array_length_1d(Commands_history)-1,history_index+1);
                    if Commands_history[history_index] != ""{
                        blink_position = string_length(Commands_history[history_index])+1;
                        }
                    else{
                        history_index-=1;
                        }
                    break;
                    
                case vk_down:
                    history_index = max(-1,history_index-1);
                    if history_index = -1{ //Change the blink position relative to the history index status. -1 can (in theory) only be acheived through decreasing with this key.
                        blink_position = string_length(Typed_text)+1;
                        }
                    else{
                        blink_position = string_length(Commands_history[history_index])+1;
                        }
                    break;
                    
                case vk_left:
                    blink_position = max(blink_position-1,1);
                    break;
                    
                case vk_right:
                    if history_index = -1{ //Change the blink position relative to the history index status. -1 can (in theory) only be acheived through decreasing with this key.
                        blink_position = min(blink_position+1,string_length(Typed_text)+1 );
                        }
                    else{
                        blink_position = min(blink_position+1,string_length(Commands_history[history_index])+1);
                        }
                    break;
                    
                
                    
                case vk_enter:
                    //We just have to execute the command, either from the Typed text, either from the Commands_history !
                    __spse_reset_history_index();
                    //Execute from the typed text !
                    __spse_execute_command(Typed_text);
                    break;
                    
                }
            }
        }
        
    keyboard_lastchar = "";
    
    if history_index = -1{
        Displayed_text = __spse_text_converter_to_sprite_index(Typed_text);
        }
    else{
        Displayed_text = __spse_text_converter_to_sprite_index(Commands_history[history_index]);
        }
        
    }
    
        
        
        
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
