<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize
Instance_to_track = "";
Instance_string_name = ""; //Unconverted: used for checks
Instance_name = ""; //Converted

STATE = "WATCH";
Extended = false;



Variables[0,0] = ""; //Serve for the name
Variables[0,1] = ""; //Serve for the value
//Converted values:
VariablesName[0] = "";
VariablesValue[0] = "";

//Dynamic position system:
yy = (instance_number(object_instance_follower)*8) mod display_get_gui_height();
xx = 35 + ((instance_number(object_instance_follower)*8) div display_get_gui_height())*70;


//Serves to mesure the distance between the instance and the center of the mouse when the instance is focused.
mx = 0;
my = 0;

//Serves to check if we are moving with the focused instance.
xfocus = 0;
yfocus = 0;

hover = false;
focus = false;

box_left = 0;
box_right = 0;
box_top = 0;
box_bottom = 0;



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update variobles, position and bounding boxes

//Mouse sync:
if object_main_console.x_mouse &gt; box_left &amp;&amp; object_main_console.x_mouse &lt; box_right &amp;&amp; object_main_console.y_mouse &gt; box_top &amp;&amp; object_main_console.y_mouse &lt; box_bottom{
    hover = true;
    if device_mouse_check_button_pressed(0,mb_left){
        focus = true;
        mx = object_main_console.x_mouse - xx;
        my = object_main_console.y_mouse - yy;
        xfocus = xx;
        yfocus = yy;
        }
    }
else{
    if object_main_console.x_mouse &gt; Instance_to_track.bbox_left &amp;&amp; object_main_console.x_mouse &lt; Instance_to_track.bbox_right &amp;&amp; object_main_console.y_mouse &gt; Instance_to_track.bbox_top &amp;&amp; object_main_console.y_mouse &lt; Instance_to_track.bbox_bottom{
        hover = true;
        }
    else{
        hover = false;
        }
    }

//Follows the mouse cursor 
if (focus){
    hover = true;
    xx = -mx + object_main_console.x_mouse;
    yy = -my + object_main_console.y_mouse;
    //Clamp the values to the border of the screen.
    xx = clamp(xx,((__spse_string_size(Instance_name)/2)+2),display_get_gui_width()-((__spse_string_size(Instance_name)/2)+2));
    yy = clamp(yy,7,display_get_gui_height()-7);
    }
    
    
//bounding boxes:
//The added char serves to have the correct length:
box_left = xx - ((__spse_string_size(Instance_string_name+"&gt;")/2)+2);
box_right = xx + ((__spse_string_size(Instance_string_name+"&gt;")/2)+2);
box_top = yy - 7;
box_bottom = yy + 7;



    
    
//UPDATE VARIABLES:
if instance_exists(Instance_to_track){
    switch(STATE){
    
        case "WATCH":
            var i = 0;
            var j;
            var __tmp_value;
            var Variables_height = array_height_2d(Variables);
            
            //First step: Flush variables that don't exist anymore:
            repeat(Variables_height){
                if !variable_instance_exists(Instance_to_track,Variables[i,0]){
                    //Flush the values:
                    Variables[i,0] = "";
                    Variables[i,1] = "";
                    VariablesName[i] = "";
                    VariablesValue[i] = "";
                    }
                i+=1;
                }
            
            //Second step: Remove empty intermediate spaces:
            
            i = 1;
            repeat(Variables_height-1){
                for(j=0;j&gt;-1;j++){
                    if (Variables[i-j,0] != "") &amp;&amp; (Variables[i-1-j,0] = ""){
                        //Transfer the variable name 
                        Variables[i-1-j,0] = Variables[i-j,0];
                        VariablesName[i-j-1] = VariablesName[i-j];
                        //Flush the rest, will be updated.
                        Variables[i-j,0] = "";
                        Variables[i-j,1] = "";
                        VariablesName[i-j] = "";
                        VariablesValue[i-j] = "";
                        
                        }
                    else{
                        i+=j; //Jump through the void created by the for loop.
                        break;
                        }
                    }
                i+=1;
                }

                
            //Step 3: Update existing variables
            i = 0;
            repeat(Variables_height){
                if Variables[i,0] != ""{
                    __tmp_value = variable_instance_get(Instance_to_track,Variables[i,0]);
                    if !is_array(__tmp_value){
                        if __tmp_value != Variables[i,1]{
                            Variables[i,1] = __tmp_value;
                            VariablesValue[i] = __spse_text_converter_to_sprite_index(string(Variables[i,1]));
                            }
                        }
                    }
                else{
                    break;
                    }
                i+=1;
                }
                //case break;
                break;
                
            
            case "TRACK":
                //A special thing with the tracking function is the dynamic creation of a pretty high number of variables
                //Step One: Flush everything !
                if is_array(Variables){
                    for(i=0;i&lt;array_height_2d(Variables);i++){
                        for(j=0;j&lt;array_length_2d(Variables,i);j++){
                            Variables[i,j] = -1;
                            }
                        }
                    }
                    
                
                var Index = "";
                Variables = "";
                VariablesName = "";
                VariablesValue = "";
                
                //Step 2: Get the value;
                Index = variable_instance_get_names(Instance_to_track);
                var tmp = 0;
                repeat(array_length_1d(Index)){
                    Variables[tmp,0] =  Index[tmp];
                    Variables[tmp,1] = variable_instance_get(Instance_to_track,Variables[tmp,0]);
                    
                    VariablesName[tmp] = __spse_text_converter_to_sprite_index(Variables[tmp,0]+":");
                    if !is_array(Variables[tmp,1]){
                        VariablesValue[tmp] = __spse_text_converter_to_sprite_index(Variables[tmp,1]);
                        }
                    else{
                        VariablesValue[tmp] = __spse_text_converter_to_sprite_index("ARRAY");
                        }
                    
                    
                    tmp += 1;
                    }
                break;
            
        } //End of the switch statement;
        
    }
else{
    //It means the instance we're looking for is missing.
    if (object_main_console.Auto_destroy_instance_follower){
        instance_destroy();
        }
    }
    


    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///We remove the focus.
if focus{
    focus = false;
    mx = 0;
    my = 0;
    
    if xfocus = xx &amp;&amp; yfocus = yy{
        //It means we want to switch the extende state:
        __spse_switch_extended_state();
        }
    
    if object_main_console.x_mouse &gt; (display_get_gui_width()/2) - 15 &amp;&amp; object_main_console.x_mouse &lt; (display_get_gui_width()/2) + 15 &amp;&amp; object_main_console.y_mouse &gt; display_get_gui_height() - 45 &amp;&amp; object_main_console.y_mouse &lt; display_get_gui_height() - 15{
        //The mouse is within the range of the suppressor:
        __spse_tracked_instance_flush(Instance_to_track);
        instance_destroy();
        
        }
    
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Apply some properties to other instances:
if object_main_console.Force_debug_instances_visible{
    Instance_to_track.visible = true;
    }
if object_main_console.Force_all_instances_visible{
    with(all){
        visible = true;
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Backup drawing settings to restore them.
draw_color = draw_get_colour();
draw_alpha = draw_get_alpha();
draw_shader = shader_current();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw a red rounded rectangle with a cross if you have the focus.
//Serves to destroy instances.
if focus{
    draw_set_colour(c_red);
    draw_roundrect(display_get_gui_width()/2-15,display_get_gui_height()-45,display_get_gui_width()/2+15,display_get_gui_height()-15,false);
    //draw_circle(display_get_gui_width()/2,display_get_gui_height()-30,15,false);
    
    draw_set_color(c_white);
    draw_line(display_get_gui_width()/2-10,display_get_gui_height()-40,display_get_gui_width()/2+10,display_get_gui_height()-20);
    draw_line(display_get_gui_width()/2-10,display_get_gui_height()-20,display_get_gui_width()/2+10,display_get_gui_height()-40);
    
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw itself.
//I want a semi white rounded rectangle:



//Set drawing conditions:
shader_reset();
draw_set_alpha(0.7);
if (hover){
    if (focus) &amp;&amp; object_main_console.x_mouse &gt; (display_get_gui_width()/2) - 15 &amp;&amp; object_main_console.x_mouse &lt; (display_get_gui_width()/2) + 15 &amp;&amp; object_main_console.y_mouse &gt; display_get_gui_height() - 45 &amp;&amp; object_main_console.y_mouse &lt; display_get_gui_height() - 15{
        draw_set_colour(c_red);
        }
    else{
        draw_set_color(c_green);
        }
    }
else{
    draw_set_color(object_main_console.Body_color_light);
    }

draw_roundrect_ext(box_left,box_top,box_right,box_bottom,5,5,false);



//Variables:
if Extended{
    for(i=0;i&lt;array_height_2d(Variables);i++){
        if Variables[i,0] != ""{
            draw_roundrect_ext(box_left,yy + (i+1)*12 - 6, box_left + __spse_string_size(VariablesName[i])+__spse_string_size(VariablesValue[i]) + 4, yy + (i+1)*12 + 6, 5,5,false);
            } 
        }
    }


draw_set_alpha(1);
draw_set_color(c_white);

//Some text:
__spse_draw_text_sprite_font(box_left+6,yy+1,Instance_name);


if Extended{
    //Time for variables to shine !
    for(i=0;i&lt;array_height_2d(Variables);i++){
        if VariablesName[i] != ""{
            __spse_draw_text_sprite_font(box_left+6,yy + (i+1)*12+1, VariablesName[i]);
            __spse_draw_text_sprite_font(box_left + __spse_string_size(VariablesName[i]) + 10, yy + (i+1)*12 + 1, VariablesValue[i]);
            }
        else{
            break; //We don't have more variables to look at.
            }
        }
    }













</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset to the usual state:
draw_set_color(draw_color);
shader_set(draw_shader);
draw_set_alpha(draw_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the overlay if the option is set to true

//Backup drawing settings to restore them.
draw_color = draw_get_colour();
draw_alpha = draw_get_alpha();
draw_shader = shader_current();


draw_set_alpha(0.3);
shader_reset();
if (hover){
    draw_set_color(c_lime);
    }
else{
    draw_set_color(c_white);
    }


if instance_exists(Instance_to_track){
    if (object_main_console.Overlay_drawing){
        draw_rectangle(
                        Instance_to_track.bbox_left,
                        Instance_to_track.bbox_top,
                        Instance_to_track.bbox_right,
                        Instance_to_track.bbox_bottom,
                        false
                        );
        }
    }
    
    
    
//Reset to the usual state:
draw_set_color(draw_color);
shader_set(draw_shader);
draw_set_alpha(draw_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
